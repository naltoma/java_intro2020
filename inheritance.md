# 継承
- 教科書10章で別のコード例とともに振り返ろう。
- ＜目次＞
  - <a href="#terms">用語説明</a>
  - <a href="#example">継承を使うと嬉しい例</a>
  - <a href="#howto-and-features">継承の仕方と特徴</a>
  - <a href="#compare">コードを見比べてみる</a>
  - <a href="#tips">継承を使うときの考え方</a>

<hr>

## <a name="terms">用語説明</a>
- 継承（inheritance）
  - 似たクラスを一つのクラスにまとめ、既存設計図を再利用して、差分だけを新たに作ることで類似クラスを作成する手法。
- スーパークラス（super class）
  - 継承する際の元となるクラスのこと。親クラスや基底クラスとも呼ばれる。
  - final修飾子を付けられたクラスは継承することができない。例えばString型（[java.lang.String](https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/String.html)）は ``public final class String`` となっているため、Stringクラスを継承することはできない。
- サブクラス（sub class）
  - スーパークラスを継承して作成したクラスのこと。子クラスとも呼ばれる。サブクラスは、スーパークラスの実装（フィールド、コンストラクタ、メソッド）を全て引き継いだクラスとなる。実装を追加するだけではなく、引き継いだ実装を上書き（overload）することもできる。
  - 継承する際には **extends** を使う。例えばString型（[java.lang.String](https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/String.html)）は ``extends Object`` となっており、Objectクラスを継承して実装されていることがわかる。

<hr>

## <a name="example">継承を使うと嬉しい例</a>
- 状況説明
  - あなたはとあるフィットネスクラブのお店を運営しているとしよう。利用者は通常会員（NormalMember）・学生会員（StudentMember）・特別会員（SpecialMember）の3種類があり、会員種別毎に料金設定が異なる。これらを継承を使わずにクラスを分けて書いた場合と、継承を用いた場合とのコードを見比べてみよう。
- コード例
  - GitHub: [ex-inheritance](https://github.com/naltoma/ex-inheritance)
  - 継承を利用していないコード例
    - package: without.inheritance, ``src/without/inheritance``
    - ``src/WithoutMain.java``
  - 継承を利用したコード例
    - package: with.inheritance, ``src/with/inheritance``
    - ``src/WithMain.java``

- GitHub上にある他人のコードの使い方
  - step 1: Git URL をコピーする。
    - 今回だと ``https://github.com/naltoma/ex-inheritance.git``
  - step 2: ターミナルで作業用ディレクトリに移動する。
    - 今回は ``~/prog2/`` だとしよう。
  - step 3: クローンを作成する。
    - ``git clone URL`` を実行。URLはコピーしたGit URLのこと。実行するとGit URL上のリポジトリ名と同じ名前のディレクトリが作成され、そこにコード類が複製される。今回の例だと ``~/prog2/ex-inheritance/`` に複製されているはず。
  - step 4: クローンディレクトリに移動して作業する。
    - 例えばVScodeで作業したいなら、cdで移動して、``code .`` とするとVSCodeで開いてくれる。（codeコマンドインストール済みならば。インストールしていないなら、一度VSCode起動して、``⌘+Shift+P``を押してコマンドパレットを開く。パレットに``shell``と入力して``shell command: Install 'code' command in PATH``を選択しよう）

<hr>

## <a name="howto-and-features">継承の仕方と特徴</a>
- クラス定義時に ``extends`` を用いてスーパークラスを指定する。
  - 全てのクラスを継承できるわけではない。finalクラスは継承できない。例えば[java.lang.Sring](https://docs.oracle.com/en/java/javase/14/docs/api/java.base/java/lang/String.html)はfinalクラスなので、これを継承してサブクラスを実装することはできない。
- スーパークラスは一つしか指定できない（単一継承）。
  - 例えば、戦士クラスを継承して騎士クラスを実装することは可能。戦士クラスと魔術師クラスの2つを継承して魔法戦士クラスを実装することはできない。（後日やるインターフェースを使うと多重継承に近いことを実装できます）
- サブクラスはスーパークラスの実装を全て引き継ぐ。
- サブクラス内でスーパークラスのコンストラクタやメソッド
- スーパークラスのコンストラクタやメソッドを上書き（Override）することができる。
  - ``@Override`` アノテーションを付けて実装を記述するだけで良い。厳密にはアノテーションしなくても良いが、アノテーションを付けておくことで上書きであることを明示でき、タイポ等のヒューマンエラーを防ぎやすくなる。例えば、上書き実装のつもりで甘やって一文字違う名前のメソッドを記述すると、新しいメソッドを実装したことになる。アノテーションを付けておくと「上書きになっていない」というエラーが出るためこのようなミスに気づきやすくなる。
  - finalメソッドは上書きできない。
- スーパークラスのコンストラクタやメソッドを呼び出すには ``super`` を使う。
  - スーパーのコンストラクタを呼び出す際には、**サブクラスのコンストラクタ内で一番最初に呼び出す** 必要がある。StudentMemberクラスのコンストラクタを確認しよう。最初の``super(_id, _name);``でスーパークラスのコンストラクタ``Member(int, String)`` を呼び出している。この前に何か処理を記述することはできない。
- コンストラクタが起動される順序はスーパークラスから。
  - ``Member <- StudentMember`` と継承した際にStudentMemberクラスのオブジェクトを生成すると、**(1)Objectクラスのコンストラクタ、(2)Memberクラスのコンストラクタ、(3)StudentMemberクラスのコンストラクタという順序でコンストラクタが連鎖的に呼び出される**。StudentMemberクラスのオブジェクトを生成した際の出力を確認してみよう。スーパークラスから連鎖的にコンストラクタが呼び出されるのは、スーパークラスの実装を引き継ぐためにオブジェクトを生成する必要があるためである。
  - (1)のObjectクラスはJava言語における全てのクラスのスーパークラスになっている。これまでのコード上は現れていないが、例えば「public class Member」としてMemberクラスを記述している時点で暗黙的にObjectクラスを継承している。
  - StudentMemberクラスのコンストラクタでは明示的に super を記述しているが、これを削除しても必ずスーパークラスから連鎖的にコンストラクタが呼び出される。確認してみよう。
- 呼び出されるメソッドを探す順序は外側（サブクラス）から。
  - オブジェクトがメソッドを呼び出す際には **外側のクラス（サブクラス）から検索され、見つかったクラスのメソッドが呼び出される**。例えば StudentMember.computeAmmount()を実行すると、StudentMemberクラスには見当たらないためスーパークラスであるMemberクラスに遡り、そこにあるcomputeAmmout()が実行される。これに対し、StudentMember.sayHello()を実行すると、StudentMemberクラス自身に見つかるためこれが実行される。
- 継承関係を表す場合は ``スーパークラス←サブクラス`` のように、スーパークラスに矢印の先が向かうように記述する。
  - 例: [クラス図の書き方とは。初心者にもわかりやすく解説](https://cacoo.com/ja/blog/how-to-write-class-diagram/)

<hr>

## <a name="compare">コードを見比べてみる</a>
- コピペコードにまつわる問題。
  - without.inheritance（継承なし）
      - 全く同じメソッドが複数クラスに存在している。ありがちな「コピペ実装」の例。動作する分には問題ないが、別観点からの問題がある。例えばcomputeAmmountメソッドに修正が必要になったとしよう。今回はNormalMember, StudentMember, SpecialMemberの3クラスしかないため3回修正するだけで良いが、今後クラス数が増えていくとその手間はクラス数に応じて増えていく。また、修正箇所が増えるということはそれだけヒューマンエラーが起きやすくなり、修正コストの増加に繋がりやすい。
  - with.inheritance（継承あり）
    - 同一メソッドはスーパークラスMemberに実装済みであり、サブクラスはその差分（今回の例ではコンストラクタのみ）だけを実装している。全てのサブクラスに共通する修正が必要な場合にはスーパークラスで修正するだけで良く、手間を省けるし、ヒューマンエラーが起きにくい。

<hr>

## <a name="tips">継承を使うときの考え方</a>
- 良い考え方
  - ``is-a関係``：「サブクラスはスーパークラスの一種である」と説明できる関係。
  - 例
    - 「自転車は乗り物の一種である」=>乗り物をスーパークラスとして実装し、それを継承してサブクラス自転車を実装する。
    - 「MacBook AirはPCの一種である」「MacBook AirはノートPCの一種である」「ノートPCはPCの一種である」
      - MacBook Air -> ノートPC -> PC
- 良くない考え方
  - is-a関係で説明できないにも関わらず継承を用いてしまう。
  - 例
    - 「iPhoneはカーナビの一種ではない」にも関わらず、「iPhone -> カーナビ」として実装してしまう。
      - 例えば、カーナビはGPS搭載であり、ナビゲーションのための関連機能（フィールドやメソッド等）が実装済みである。同様にGPSが搭載されているからこれらの便利な機能を使いたいという理由でカーナビクラスを継承してiPhoneをサブクラスとして実装してしまうのは良くない。カーナビは価格の都合上画質がVGA等低く抑えられていることが多いが、これを継承してしまうとiPhone上の画質も粗くなる。またカーナビは基本的にアプリを切り替えるという概念自体が薄く、これを継承したiPhoneも同様の使い勝手に抑えられてしまう。
